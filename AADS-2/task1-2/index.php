<?php

$array = [1, 5, 6, 8, 3, 2, 0, 3, 4, 9, 7];


function quickSort($arr, $low, $high) {
    $i = $low;
    $j = $high;
    $middle = $arr[ ( $low + $high ) / 2 ];   // middle – опорный элемент; в нашей реализации он находится посередине между low и high
    do {
        while($arr[$i] < $middle) ++$i;     // Ищем элементы для правой части
        while($arr[$j] > $middle) --$j;     // Ищем элементы для левой части
        if($i <= $j){
// Перебрасываем элементы
            $temp = $arr[$i];
            $arr[$i] = $arr[$j];
            $arr[$j] = $temp;
// Следующая итерация
            $i++; $j--;
        }
    }
    while($i < $j);

    if($low < $j){
// Рекурсивно вызываем сортировку для левой части
        quickSort($arr, $low, $j);       //
    }

    if($i < $high){
// Рекурсивно вызываем сортировку для правой части
        quickSort($arr, $i, $high);
    }

}


quickSort( $array,0, count($array) - 1);

var_dump( $array );


//Если я все верно понял, деление массива пополам каждый раз это log N(2 можно отбросить т.к. это константа).
// Это значение берется таким образом, для примера например для поиска значения в массива из 8 элементов требуется
// 3 деления, для массива из 16 - 4 деления и тд. Отсюда и получается сложность log N Проход по
// каждой половинке массива это N/2(половинок две, поэтому N/2 + N/2 = N). Так как кол-во проходов по половинкам напрямую зависит
// размера исходного массива( от того сколько раз мы будем делить его на части ) то нам необходимо умножить эти сложности.
// Итого общая сложность получается N * log N. Всякие мелкие операции, такие как смена двух эелемнтов массива являются константами
// поэтому их отбрасываем.